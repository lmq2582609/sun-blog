<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>第4章 汇编语言 | 小太阳的博客</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/sun-blog/assets/images/logo.png">
    <meta name="description" content="一名爱学习的好同志">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/sun-blog/assets/css/0.styles.13e57b2d.css" as="style"><link rel="preload" href="/sun-blog/assets/js/app.8cc2e543.js" as="script"><link rel="preload" href="/sun-blog/assets/js/4.eab32c03.js" as="script"><link rel="preload" href="/sun-blog/assets/js/1.3b1cd4a9.js" as="script"><link rel="preload" href="/sun-blog/assets/js/5.dc06e3fc.js" as="script"><link rel="prefetch" href="/sun-blog/assets/js/10.df3e37ce.js"><link rel="prefetch" href="/sun-blog/assets/js/11.c9774bee.js"><link rel="prefetch" href="/sun-blog/assets/js/12.9751fddf.js"><link rel="prefetch" href="/sun-blog/assets/js/13.667022f4.js"><link rel="prefetch" href="/sun-blog/assets/js/14.ab576c45.js"><link rel="prefetch" href="/sun-blog/assets/js/15.fd4eecbb.js"><link rel="prefetch" href="/sun-blog/assets/js/16.e54de70a.js"><link rel="prefetch" href="/sun-blog/assets/js/17.a00ae516.js"><link rel="prefetch" href="/sun-blog/assets/js/18.77725c20.js"><link rel="prefetch" href="/sun-blog/assets/js/19.d39febe0.js"><link rel="prefetch" href="/sun-blog/assets/js/20.6c5b3c3d.js"><link rel="prefetch" href="/sun-blog/assets/js/3.4daabc5b.js"><link rel="prefetch" href="/sun-blog/assets/js/6.4236bf8c.js"><link rel="prefetch" href="/sun-blog/assets/js/7.0c2226aa.js"><link rel="prefetch" href="/sun-blog/assets/js/8.6dcac8cf.js"><link rel="prefetch" href="/sun-blog/assets/js/9.51145d20.js">
    <link rel="stylesheet" href="/sun-blog/assets/css/0.styles.13e57b2d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-7dd95ae2><div data-v-7dd95ae2><div class="password-shadow password-wrapper-out" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>小太阳的博客</h3> <p class="description" data-v-59e6cb88>一名爱学习的好同志</p> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2023
      </a></span></div></div> <div class="hide" data-v-7dd95ae2><header class="navbar" data-v-7dd95ae2><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/sun-blog/" class="home-link router-link-active"><img src="/sun-blog/assets/images/logo.png" alt="小太阳的博客" class="logo"> <span class="site-name">小太阳的博客</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/sun-blog/computer-dao/" class="nav-link router-link-active"><i class="undefined"></i>
  计算机之道
</a></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-7dd95ae2></div> <aside class="sidebar" data-v-7dd95ae2><div class="personal-info-wrapper" data-v-1fad0c41 data-v-7dd95ae2><!----> <!----> <div class="num" data-v-1fad0c41><div data-v-1fad0c41><h3 data-v-1fad0c41>6</h3> <h6 data-v-1fad0c41>文章</h6></div> <div data-v-1fad0c41><h3 data-v-1fad0c41>0</h3> <h6 data-v-1fad0c41>标签</h6></div></div> <ul class="social-links" data-v-1fad0c41></ul> <hr data-v-1fad0c41></div> <nav class="nav-links"><div class="nav-item"><a href="/sun-blog/computer-dao/" class="nav-link router-link-active"><i class="undefined"></i>
  计算机之道
</a></div> <!----></nav> <ul class="sidebar-links"><li><a href="/sun-blog/computer-dao/" aria-current="page" class="sidebar-link">前言</a></li><li><a href="/sun-blog/computer-dao/1/第1章-计算机简述.html" class="sidebar-link">第1章-计算机简述</a></li><li><a href="/sun-blog/computer-dao/2/第2章-机器指令与编程语言.html" class="sidebar-link">第2章-机器指令与编程语言</a></li><li><a href="/sun-blog/computer-dao/3/第3章-编译原理.html" class="sidebar-link">第3章-编译原理</a></li><li><a href="/sun-blog/computer-dao/4/第4章-汇编语言.html" class="active sidebar-link">第4章-汇编语言</a></li><li><a href="/sun-blog/computer-dao/5/第5章-C语言.html" class="sidebar-link">第5章-C语言</a></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>第4章 汇编语言</h3> <!----> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2023
      </a></span></div></div> <div data-v-7dd95ae2><div data-v-7dd95ae2><main class="page"><section style="display:;"><div class="page-title"><h1 class="title">第4章 汇编语言</h1> <div data-v-8a445198><!----> <i class="iconfont reco-date" data-v-8a445198><span data-v-8a445198>2022/11/20</span></i> <!----> <!----></div></div> <div class="theme-reco-content content__default"><p>学习汇编语言，只需要了解汇编语言规定的一些语法就可以了，了解汇编语言都使用了哪些指令，随着这些指令的出现，还会涉及到一些其他知识点，不断引出新的内容，先来看看汇编语言长什么样子：</p> <div class="language- extra-class"><pre class="language-text"><code>start2:
	movw	%cs, %ax
	movw	%ax, %ds
	movw	%ax, %es
	movw	%ax, %ss
	movw	$0x7c00, %sp
	sti
	cld
</code></pre></div><h2 id="_4-1-汇编语法"><a href="#_4-1-汇编语法" class="header-anchor">#</a> 4.1 汇编语法</h2> <p>汇编语言包含操作码、操作数和伪指令：</p> <ul><li>操作码：表示这条指令能完成什么样的工作。比如mov能完成移动数据的工作。这个指令也就是机器码的助记符，每个指令都有对应的机器码如mov移动、add做加法等等。汇编语言的指令是不区分大小写的，所以写成mov和MOV都是移动的意思。</li> <li>操作数：用于参与操作码所进行的操作。如a+1，+就是操作码，a和1就是操作数。写好代码后由汇编器解析成010101的机器指令就可以了。所以说汇编语言=机器语言，没有太多的花哨的操作，只不过就是对阅读和编写更加方便。</li> <li>伪指令：汇编语言中还包含伪指令，伪指令没有对应的机器码，是专门给汇编器用的，计算机并不执行。比如.data、.text等。</li></ul> <p>汇编语言语法一般是指令+操作数，这里就需要注意Intel的汇编和AT&amp;T汇编的语法是不一样的，如将数据8移动到ax寄存器，Inte的汇编：<code>mov ax, 8</code>，AT&amp;T的汇编：<code>movl $8, %ax</code>，不过差别并不大，不管是看到哪种语法，都能知道是将数据8移动到ax寄存器中。</p> <p>AT&amp;T汇编语法使用%作为所有寄存器名称的前缀，以$作为操作数的前缀，它的源操作数在左边，目标操作数在右边：<code>movl $8, %ax</code>。</p> <p>Intel汇编语法不需要寄存器和操作数前缀，它的源操作数在右边，目标操作数在左边：<code>mov ax, 8</code>。</p> <p>Linux系统由于历史原因使用的就是AT&amp;T汇编，AT&amp;T可以使用GNU汇编器编译，Intel汇编可以使用MASM汇编器编译。</p> <blockquote><p>参考文献说明：《汇编语言》第三版王爽著</p></blockquote> <h2 id="_4-2-mov、add、sub指令"><a href="#_4-2-mov、add、sub指令" class="header-anchor">#</a> 4.2 MOV、ADD、SUB指令</h2> <h3 id="_4-2-1-mov"><a href="#_4-2-1-mov" class="header-anchor">#</a> 4.2.1 MOV</h3> <p>mov指令是移动数据。那么数据移动的方式有几个？无非就是：寄存器 -&gt; 内存，内存 -&gt; 寄存器，寄存器 -&gt; 寄存器，或者如果ISA指令集支持的话还可以直接从内存 -&gt; 内存，这就取决于ISA指令集是否支持。如Intel x86处理器就不允许内存和内存之间的数据移动，不支持怎么办？也好办，那就通过寄存器中转一下呗。</p> <p>语法：<code>mov 寄存器，数据</code> -&gt; <code>mov ax, 8</code> -&gt; 将数据8移动到ax寄存器。就像是<code>ax = 18</code>。</p> <p>语法：<code>mov 寄存器，寄存器</code> -&gt; <code>mov ax, bx</code> -&gt; 将bx寄存器中的数据移动到ax寄存器。就像是<code>ax = bx</code>。</p> <h3 id="_4-2-2-add"><a href="#_4-2-2-add" class="header-anchor">#</a> 4.2.2 ADD</h3> <p>add指令就是加法运算。</p> <p>语法：<code>add 寄存器，寄存器</code> -&gt; <code>add ax, bx</code>-&gt; 将ax寄存器和bx寄存器中的值相加，结果存到ax寄存器中。就像是<code>ax = ax + bx</code>。</p> <p>语法：<code>add 寄存器，数据</code> -&gt; <code>add ax, 8</code> -&gt; 将ax寄存器中的值加上8，结果存到ax寄存器中。就像是<code>ax = ax + 8</code>。</p> <h3 id="_4-2-3-sub"><a href="#_4-2-3-sub" class="header-anchor">#</a> 4.2.3 SUB</h3> <p>sub指令就是减法运算。</p> <p>语法：<code>sub 寄存器，数据</code> -&gt; <code>sub ax, 9</code> -&gt; 用ax寄存器中的值减9，结果存入ax寄存器中。就像是<code>ax = ax -9</code>
语法：<code>sub 寄存器，寄存器</code> -&gt; <code>sub ax, bx</code> -&gt; 用ax寄存器中的值减bx寄存器中的值，结果存入ax寄存器中。就像是<code>ax = ax - bx</code></p> <h2 id="_4-3-指令地址寄存器"><a href="#_4-3-指令地址寄存器" class="header-anchor">#</a> 4.3 指令地址寄存器</h2> <p>MOV、ADD、SUB这些指令，存放于内存中，程序在执行时，会有很多指令需要执行，怎么能知道指令执行到哪里了呢？就需要有一个寄存器去存储正在执行的指令在内存中的地址，这个寄存器就是指令地址寄存器。它保存着当前执行指令的内存地址的寄存器，简称IP寄存器(instruction pointer)。每次执行完指令，这个IP寄存器的值都会变动，它就像一个指针，移来移去的。</p> <p><img src="/sun-blog/assets/img/image.a2a844f1.png" alt="指令地址寄存器"></p> <h2 id="_4-4-寄存器组"><a href="#_4-4-寄存器组" class="header-anchor">#</a> 4.4 寄存器组</h2> <p>寄存器是CPU内部重要的数据存储资源，是汇编程序员能直接使用的硬件资源之一。由于寄存器的存取速度比内存快，所以，在用汇编语言编写程序时，要尽可能充分利用寄存器的存储功能。寄存器分为专用寄存器和通用寄存器：</p> <ul><li>专用寄存器：寄存器只能用于它所标明的用途。</li> <li>通用寄存器：寄存器除了自身表明的用途，还可以任意使用。</li></ul> <p>寄存器的大小是多大呢？寄存器的大小一般和CPU的位数一致，比如32位CPU，寄存器的大小就是32位，64位CPU，寄存器的大小就是64位的，多个寄存器就形成了一个寄存器组。</p> <p><img src="/sun-blog/assets/img/image2.1506fe05.png" alt="寄存器组"></p> <h2 id="_4-5-立即数和内存地址"><a href="#_4-5-立即数和内存地址" class="header-anchor">#</a> 4.5 立即数和内存地址</h2> <h3 id="_4-5-1-立即数"><a href="#_4-5-1-立即数" class="header-anchor">#</a> 4.5.1 立即数</h3> <p><code>mov ax, 8</code>，8这个数据本身就存在于指令中，像这种嵌在指令里的数据就叫做立即数。也可以理解成立即就能获取到的数。</p> <h3 id="_4-5-2-内存地址"><a href="#_4-5-2-内存地址" class="header-anchor">#</a> 4.5.2 内存地址</h3> <p>我们的代码写完，存储在硬盘上，经过编译器的编译，运行时加载到内存中，在内存中，一个最小寻址单元是1byte，那么在内存中获取数据，怎么锁定数据的位置呢？就需要内存地址，内存地址就像是给内存中每个单元都编了一个号。</p> <p><img src="/sun-blog/assets/img/image3.3720301b.png" alt="内存地址"></p> <p>给内存每个单元都标了一个号，这个号就是内存地址，取数据时根据这个地址就可以获取对应的数据。那这里就有疑问了，计算机只认识0101的二进制，我们知道二进制的代码是不利于编写和排错的，那在写代码时想要操作内存，就需要指明内存地址才能操作，所以在代码中使用十六进制来表示内存。</p> <h3 id="_4-5-3-十六进制"><a href="#_4-5-3-十六进制" class="header-anchor">#</a> 4.5.3 十六进制</h3> <p>十六进制就是0~9对应0~9，a~f对应10~15。1个16进制数，可以抵4bit也就是4个二进制位。比如要操作内存地址为<code>0000000000000000(二进制)</code>，用十六进制就可以写为：<code>0000(十六进制)</code>，这就简洁了很多，十六进制以0x开头，用于区别于其他进制。</p> <h3 id="_4-5-4-高地址与低地址"><a href="#_4-5-4-高地址与低地址" class="header-anchor">#</a> 4.5.4 高地址与低地址</h3> <p>一个内存地址范围<code>0x00000000 ~ 0xffffffff</code>的4GB内存，它们是有高低之分的，如何区分高地址和低地址，从它们的大小就能看出来，0小，f大，所以靠近<code>0xffffffff</code>的就是高地址，靠近<code>0x00000000</code>的就是低地址。高的英文是Hign，所以高地址一般用h简写，低的英文是Low，所以低地址一般用l简写。</p> <p><img src="/sun-blog/assets/img/image4.5cd7eeaa.png" alt="高地址与地址"></p> <h2 id="_4-6-总线"><a href="#_4-6-总线" class="header-anchor">#</a> 4.6 总线</h2> <p>CPU和内存中间数据获取和写回需要交互，那就需要在他们之间连一根线，来控制是读操作还是写操作，所以叫做控制总线。知道了是读还是写，那还要知道要操作的位置，也就是地址，所以叫地址总线。那么不管是读还是写，操作的都是数据，所以还需要有数据总线进行数据传输。这些就是计算机的总线。</p> <ul><li>控制总线：CB（Control Bus）。用来传送控制信号，比如读/写等，叫做控制总线。</li> <li>地址总线：AB（Address Bus）。用于读写操作时指明地址的，叫做地址总线。</li> <li>数据总线：DB（Data Bus）。用于发送数据的，叫做数据总线。</li></ul> <p>那么总线它也是有位数的，因为总线的位数决定了发送数据的大小，通常与CPU的位数相关，如16位的CPU，总线就是16bit的，每次发送数据就能发送16bit的数据。传输情况以16位总线为例，16位的控制总线就可以发送2的16次方个种类的信号。16位的地址总线就可以指明2的16次方的地址。16位的数据总线一次传输16bit的数据。</p> <p>思考一下，既然数据总线是用来传输数据的，那岂不是数据总线越大，一次能传输的数据也就越多，那是不是数据总线的位数越大越好？确实是越大越好，数据总线一次能同时传输的数据就越多，但要考虑一个问题是硬件应该如何设计，越密集的线路，它们之间就会产生电磁干扰，比如把0传过去变成了1应该如何处理？所以这是由电气特性来决定的，目前来说我们的计算机都是64位的，数据总线一般也是64位的。超级计算机的数据总线会更大，但它的占地空间也非常大。</p> <blockquote><p>参考文献说明：《计算机组成原理》第1章1.6.2节、《计算机组成与体系结构》第4章4.1.2节。</p></blockquote> <h2 id="_4-7-内存分段"><a href="#_4-7-内存分段" class="header-anchor">#</a> 4.7 内存分段</h2> <h3 id="_4-7-1-为什么要分段"><a href="#_4-7-1-为什么要分段" class="header-anchor">#</a> 4.7.1 为什么要分段？</h3> <p>Intel在8086 CPU和8088 CPU时代是16位的，它们的寄存器也是16位的，CPU想要访问内存，是通过指令地址寄存器来访问，因为指令地址寄存器储存了当前CPU正在执行的指令在内存中的地址，而内存中的最小寻址单元是1byte(8bit)，在8086和8088时代，指令地址寄存器是16bit，那么指令地址寄存器可以访问的内存范围就是216，也就是64kb，这是如何计算的？16bit的寄存器共有16个二进制位，它能表示的范围是：<code>0000 0000 0000 0000 ~ 1111 1111 1111 1111</code>，也就是0 ~ 65535(216-1)，指令地址寄存器用来寻址的话，可寻址的范围就是216个内存单元(每个单元是1byte)，也就是216个byte，就是64kb。</p> <p>此时内存厂商说了，我这里有1M的内存(别小看这1M内存，8086和8088时代可是1978年哦)，你的CPU只能寻址64kb，也太小了吧。但当时Intel可以寻址64kb的CPU已经设计出来了，这时候怎么办？怎样做才能用最小的改动来满足1M内存的寻址？寻址1M的内存需要220个byte，也就是需要20bit的寄存器，另外还需要20bit的地址总线。首先要满足20bit的数据总线，这个是比较好实现的。难度在于如何改造16bit的寄存器让它扩张到20bit，由于CPU都已经设计好了，想改就等于牵一发而动全身。所以Intel工程师想了一个妙招，这位工程师当时看到了他女儿的一道数学题：</p> <p><img src="/sun-blog/assets/img/image5.f0d9b350.png" alt="内存分段"></p> <p>从A点到B点的距离是500米，中间有堵墙，A点距离墙是200米，问：小明从墙的位置开始走，需要走多少米能走到B点。答案是300米 -&gt; <code>500 - 200 = 300</code>。那么500米即可以用1个500米来表示，也可以用200+300的方式去表示，所以那能不能用一个寄存器表示200米，另一个寄存器表示300米，两个寄存器相加不就等于500米嘛。所以就有了内存分段的概念，但内存分段并不是内存厂商给划分的，而是来自CPU。</p> <p>既然指令地址寄存器的寻址范围不够，那就在加一个16位的寄存器，用它其中的4位加上指令地址寄存器的16位，就可以满足1M内存的寻址了，这个寄存器就叫做段寄存器。将内存分段，用段寄存器来表示要操作的数据在哪一个段里面，用指令地址寄存器来表示在段中的偏移量，这就搞定了，最终指令地址寄存器(16bit)+段寄存器(16bit中的4bit)，就可以寻址1M的内存了。</p> <p><img src="/sun-blog/assets/img/image6.42a48179.png" alt="内存分段"></p> <p>在8086和8088时代，CPU将内存划分了几段能满足1M内存的寻址呢？段寄存器中的4bit用来划分内存，24=16也就是分成了16个段，每一个段都是64kb刚好可以用指令地址寄存器来寻址，那么16个段 * 64kb = 1M，就完成了1M内存的寻址。</p> <h3 id="_4-7-2-代码段"><a href="#_4-7-2-代码段" class="header-anchor">#</a> 4.7.2 代码段</h3> <p>我们平时写代码为了有利于扩展，都会将代码按功能或者按照其他方式写到各个文件里，比如Java语言，方法与方法之间的调用，<code>userService.login(user);</code>我们不可能将所有的代码都写到一个文件里，这也不利于扩展，所以都是分别编写到多个文件的，通过链接器将它们链接在一起。运行时就会编程一个一个的代码片段，这就是代码段了，代码也是指令，所以代码段也可以叫指令段。程序运行以后，如果想修改代码就需要重新编译了，所以说代码段是只读的，不可以修改。</p> <p><img src="/sun-blog/assets/img/image7.43714342.png" alt="代码段"></p> <p>代码段也就是指令段，前面说只使用指令地址寄存器无法满足1M内存的寻址，那么代码段在运行时，就需要一个寄存器来存储当前执行的是哪一个代码段，这个寄存器就叫做代码段寄存器(简称CS，Code Segment)。使用CS+IP寄存器来操作代码段，CS寄存器保存了当前执行指令在哪个段中，IP寄存器保存了指令在这个段中的偏移地址。</p> <h3 id="_4-7-3-堆栈段"><a href="#_4-7-3-堆栈段" class="header-anchor">#</a> 4.7.3 堆栈段</h3> <p>代码中要做加减乘除等运算，所需要的数据如何存放呢？这其中涉及到数据的私有和共享的问题。代码段与代码段应该是隔离开的，一个代码段内部使用的数据属于私有数据，代码段与代码段之间都能使用的数据属于共享数据。这就牵扯到了堆和栈，它们对外看只是一块内存空间，在Intel CPU看来它们都叫栈段，在程序的角度划分成了堆和栈，所以叫堆栈段也没有问题。</p> <p>栈内存用于存储代码段的私有数据，代码段有很多个，每个代码段的数据使用后就要释放内存，当一个代码段在栈内存中开辟一块空间来存放自己代码段所使用的数据时，开辟的这块空间叫做栈帧，专门用于存放代码段的私有数据。栈内存使用时由高地址向低地址扩张。</p> <p><img src="/sun-blog/assets/img/image8.b943c748.png" alt="堆栈段"></p> <p>由于栈这个数据结构先进后出，后进先出的特性，所以栈内存从微观上看每个栈帧都是用栈的数据结构来保存数据，从宏观上看整个栈内存也是使用栈的数据结构来保存数据。</p> <p>代码段私有数据存储搞定了，代码段与代码段之间的共享数据还没地方存储，那就在开辟一块堆空间呗，堆空间就是专门来保存代码段与代码段之间共享的数据，里面都是一些动态的数据，是随着指令的执行动态产生的。</p> <p><img src="/sun-blog/assets/img/image9.6f5f6d19.png" alt="堆栈段"></p> <p>栈内存存储代码段的私有数据，堆内存存储代码段之间的共享数据，但它们对外实际就是一块连续的内存，只是在这块内存里以程序的角度区分了堆和栈，同样在执行时需要有一个寄存器来指向要操作的地址，就是栈段寄存器，也可以叫堆栈段寄存器(简称SS，Stack Segment)。在操作栈时，使用PUSH压栈和POP出栈操作，如<code>push ax、pop ax</code>等。CPU如何知道要操作的栈的位置？SS寄存器存储了当前要操作的段的地址，SP寄存器存储了在这个段中的偏移地址，在执行push和pop指令时，CPU从SS和SP寄存器得到栈顶的地址。</p> <h3 id="_4-7-4-栈顶和栈底寄存器"><a href="#_4-7-4-栈顶和栈底寄存器" class="header-anchor">#</a> 4.7.4 栈顶和栈底寄存器</h3> <p>既然是在栈内存中开辟栈帧，那栈帧就要有一个界限，所以就衍生出两个寄存器，栈顶寄存器(简称SP，Stack Pointer)和栈底寄存器(简称BP，Base Pointer，也叫栈基地址寄存器)。这两个寄存器很好理解，栈底寄存器保存着栈的栈底，栈顶寄存器保存着栈的栈顶，栈内存在初始化时是空的，所以栈顶=栈底，随着数据不断的存入，栈底保持不变，栈顶开始移动。</p> <p><img src="/sun-blog/assets/img/image10.01b0cf3b.png" alt="栈顶和栈底"></p> <h3 id="_4-7-5-数据段"><a href="#_4-7-5-数据段" class="header-anchor">#</a> 4.7.5 数据段</h3> <p>还有一些数据是应该考虑的，就是程序运行时就固定了的数据，如Java里的static、final数据，这些数据是程序初始就有的，它们存放在哪？答案就是数据段，数据段保存什么数据？是保存编译时就存在的数据，也就是静态数据。数据段中的数据如何存取？其实数据还是存放在堆中的，数据段中只是保存了数据在堆中的地址，通过这个地址就可以操作数据段中的数据了。</p> <p><img src="/sun-blog/assets/img/image11.72c5882a.png" alt="数据段"></p> <p>在操作数据段时也需要有一个寄存器来存储地址，就是数据段寄存器(Data Segment)。使用DS+[address]来操作数据段，DS存储了要访问的数据段的内存地址，偏移地址用[...]给出，例如<code>mov al, [0]</code></p> <h3 id="_4-7-6-操作系统内存及内存排列"><a href="#_4-7-6-操作系统内存及内存排列" class="header-anchor">#</a> 4.7.6 操作系统内存及内存排列</h3> <p>操作系统也是软件，操作系统也是运行在内存，与其他软件都运行在内存它们之间不会相互影响吗？假如有其他的程序直接控制操作系统怎么办？或者其他程序利用一些手段去控制操作系统的内存怎么办？那一定不能的，因为操作系统地位特殊，它管理了一切，既然地位特殊，所以在内存的顶端，开辟一块内存，是操作系统专属的。</p> <p>操作系统内存与其他内存是如何排列的？它们有一个先后顺序，由高地址到低地址依次是：</p> <p><img src="/sun-blog/assets/img/image12.d2bccc32.png" alt="内存排列"></p> <p>此时注意到最下面有一块内存是空的，它是做什么的，我们写代码有时候我们想让某个数据初始化的时候是一个无效值，怎么办？这就是最下面的一块内存，比如java里写了一个<code>Object a = null;</code>再比如C语言写了一个<code>int *p = NULL;</code>所以就空出了一片内存。</p> <h2 id="_4-8-call指令和ret指令"><a href="#_4-8-call指令和ret指令" class="header-anchor">#</a> 4.8 CALL指令和RET指令</h2> <h3 id="_4-8-1-call指令"><a href="#_4-8-1-call指令" class="header-anchor">#</a> 4.8.1 CALL指令</h3> <p>call指令是跳转的意思。代码段A调用代码段B就需要用到call指令，这就像方法调用一样。</p> <p><img src="/sun-blog/assets/img/image13.5ffe6146.png" alt="CALL"></p> <p>这里有一个问题就是指令跳转过去如何返回？而且代码段调用就要开辟新的栈帧，而栈顶寄存器和栈底寄存器又要如何保存？比如a调b，b调c。这里就用到一个巧妙的办法，就是在调用其他代码段开辟新的栈帧时，将上一个代码段的栈底保存过来，然后再往新的栈帧里面存放数据，至于栈顶则无需关心，因为栈顶只需要随着栈的扩容移动即可，栈顶始终是当前正在执行的代码段的数据。</p> <p><img src="/sun-blog/assets/img/image14.f2443823.png" alt="CALL"></p> <p>这样保存，在数据弹出之后就可以按原路返回了。实际上就是开辟栈帧时，保存了上一个代码段栈底的位置。</p> <p><img src="/sun-blog/assets/img/image15.f82f59e5.png" alt="CALL"></p> <p><img src="/sun-blog/assets/img/image16.42b09a20.png" alt="CALL"></p> <h3 id="_4-8-2-状态寄存器"><a href="#_4-8-2-状态寄存器" class="header-anchor">#</a> 4.8.2 状态寄存器</h3> <p>代码段与代码段之间的跳转，什么情况下会发生跳转？跳转总需要有一个状态，就像if else的代码，满足了一些条件进行跳转，这个状态也需要有一个寄存器来保存跳转的状态，叫做状态寄存器(EFLAGS)，在代码段之间跳转用于保存状态，配合call指令使用。当然这个寄存器中还保存了很多个状态，之后遇到了再介绍，现在我们只需要知道它可以保存代码段之间跳转的状态即可。</p> <h3 id="_4-8-2-ret指令"><a href="#_4-8-2-ret指令" class="header-anchor">#</a> 4.8.2 RET指令</h3> <p>ret指令用于返回。call指令执行后，如何返回到之前的位置，就需要ret指令的配合，ret指令会修改IP寄存器(指令地址寄存器)的内容来实现返回，它会返回到执行call指令的下一条指令，可能下面的图会让你更容易理解。</p> <p><img src="/sun-blog/assets/img/image17.1a674989.png" alt="RET"></p> <p>通过上图可以发现，其实就是修改了IP寄存器(指令地址寄存器)的内容，将当前指令换成了下一个要执行的指令。与ret指令类似的还有retf指令，不同的是retf指令还会修改CS代码段寄存器的内容，retf指令通过修改CS+IP寄存器的内容来实现转移。</p> <h2 id="_4-9-intel-cpu发展史"><a href="#_4-9-intel-cpu发展史" class="header-anchor">#</a> 4.9 Intel CPU发展史</h2> <p>1978年，IA-32架构之前先有16位CPU，分别是8086和8088。8086CPU有16位寄存器和16位数据总线和20位地址总线，能寻址1M的地址空间。8088CPU除了和8086CPU一样以外，8088CPU还有一个8位的数据总线。</p> <blockquote><p>注：IA-32：Intel Architecture 32bit，指的是Intel的32位CPU得体系架构</p></blockquote> <p>1982年，推出了286处理器。286处理器在IA-32架构中引入了保护模式，保护模式使用段寄存器的内容作为选择子或指向描述符表。描述符提供了24bit基地址，能够寻址16M的内存，支持基于段交换的虚拟内存管理，以及一些保护机制。包括段界限检查、只读和只执行段选项、4个特权级。</p> <p>1985年，推出了386处理器。386处理器在IA-32家族中是32位的处理器，引入了32位寄存器用于寻址和保存操作数，每个32位寄存器可以包含2个16位寄存器，也就是可以切割为高16位和低16位，允许向下兼容，32位机中可以只使用16位来兼容以前的机器。提供了虚拟8086模式，意思就是只用16位寄存器，把自己内部的组件完全兼容8086时代的操作，所以是虚拟8086模式。386还支持：32位的地址总线，支持4GB的物理内存，支持分段内存模型和平坦内存模式，支持分页，固定4kb的分页大小，为虚拟内存管理提供的一种方法，支持并行操作。</p> <p>1989年，486处理器添加了额外的并行执行的兼容性，通过扩展386处理器的指令解码和执行单元，把它切割成了5个流水线，每一个步骤的操作数都可以并行执行。还包括8kb的芯片缓存也就是一级缓存，引入了x87的FPU浮点运算器，还支持节能电源(休眠)和系统管理的能力。</p> <p>1993年，Intel奔腾处理器添加了第二条流水线，芯片上(on-chip)的一级缓存大小翻倍(一个CPU有很多核，CPU的每个核就是一个chip，on-chip就是在这个核上的一级缓存翻倍)，8kb用来存代码(I-cache(Instruction-cache)：用于缓存指令)，8kb用来存数据(d-cache(Data-cache)：用于缓存数据)，数据缓存使用MESI协议来支持更有效的写回缓存(write-back)，而不仅仅是之前I486处理器的直写缓存(write-through)，增加了芯片上分支表的分支预测，提升了循环结构的性能，还添加了：</p> <ul><li>扩展的虚拟8086模式，并允许4MB和4KB的页。</li> <li>128位和256位的内部数据路径增加了内部数据传输的速度(这里是内部传输速度指的是CPU内部)</li> <li>外部数据总线增加到64位</li> <li>支持多处理器系统的APIC(中断控制器)</li> <li>支持无胶双处理器系统的双处理器模式</li></ul> <p>我们之后研究的汇编代码，学习的都是Intel平台的指令集，因为该平台为PC端的统治者，而且为CISC指令集，所以选择Intel平台来研究。既然要研究Intel，那么就得研究Intel的历史，没有谁比Intel开发者更了解他们的平台，所以我们需要看他们写的手册，也就是Intel手册。</p> <p>Intel手册分为4卷，第1卷介绍了Intel的历史，第2卷讲Intel的指令集，第3卷讲如何面向CPU编程，第4卷讲了一些平台相关的寄存器的东西。我们看Intel手册，只需要阅读第1卷和第3卷，第2卷和第4卷用来查询即可。</p> <p>通过了解Intel的历史中可以发现，在386处理器时代，已经是32位机了，可以说是麻雀虽小五脏俱全，在1993年引入奔腾处理器之后，都是一些硬件层面上的提升，所以对于学习来讲，学习Intel的32位CPU可以说是非常有必要的。而且我们发现Intel历史中涉及到很多陌生的词汇，如：虚拟内存、特权级、指令流水线等等，下面就逐一学习。</p> <h2 id="_4-10-x86-32位cpu-保护模式"><a href="#_4-10-x86-32位cpu-保护模式" class="header-anchor">#</a> 4.10 x86(32位CPU)保护模式</h2> <h3 id="_4-10-1-虚拟内存"><a href="#_4-10-1-虚拟内存" class="header-anchor">#</a> 4.10.1 虚拟内存</h3> <p>之前的分析中，提到OS操作系统是一个软件，在内存的最上层有一块OS的专属内存，此时如果CPU不做出一些改动，所有的程序都可以通过指令地址寄存器+段寄存器来随意操作内存，当然可操作的内存中也包括OS的专属内存，这是不具备任何保护措施的。</p> <p>386处理器时代，CPU是32位的，引入了4GB的内存，在1985年4GB的内存可以说是非常大了，有4GB的内存就可以运行更多的程序，如何提供保护措施呢？首先能想到的就是程序与程序之间的隔离，只要不让程序和程序之间在内存中能够感知到彼此的存在就可以了。那如何隔离呢？那就是让程序与程序之间都只拥有自己的内存，让每个程序感觉自己独占了整个内存就可以了，这就是虚拟内存。虚拟内存就像是物理内存与程序之间的中转站，同时映射到真实的物理内存。</p> <p><img src="/sun-blog/assets/img/image18.92a33b68.png" alt="虚拟内存"></p> <p>正是这样的设计实现了程序与程序之间的隔离。那问题来了，操作内存时需要有内存地址，虚拟内存又是假的内存，它只是让程序看起来像真的内存，那操作虚拟内存的时候如何找到映射的物理内存？是否可以做一个映射表？让每个程序的内存映射都存放到这个表里：</p> <p><img src="/sun-blog/assets/img/image19.c5838581.png" alt="虚拟内存"></p> <p>在16位机时代，有了内存分段，使用指令地址寄存器+段寄存器(代码段寄存器、数据段寄存器、栈段寄存器等都属于段寄存器)，就可以操作物理内存，段寄存器中的4bit指明了要操作哪一段内存，指令地址寄存器中的16bit指明了段中的偏移量。</p> <p>在32位机时代，设计32位CPU时就已经知道内存大小是4GB了，4GB内存的寻址就必须要有32位的地址总线，32位的指令地址寄存器，而4GB内存就等于需要有232个byte才能完成4GB的寻址，刚好32位机的指令地址寄存器和总线就是32位的，所以386CPU就是这样设计的。既然32位的指令地址寄存器已经可以满足4GB内存的寻址了，那还要段寄存器干什么？此时我们注意到内存映射表它好像是一个数组，那么段寄存器就派上用场了，使用段寄存器保存下标用来查表非常合适。</p> <h3 id="_4-10-2-全局描述符表-gdt-和全局描述符表寄存器-gdtr"><a href="#_4-10-2-全局描述符表-gdt-和全局描述符表寄存器-gdtr" class="header-anchor">#</a> 4.10.2 全局描述符表(GDT)和全局描述符表寄存器(GDTR)</h3> <p>这个内存映射表总是要有一个名字的，既然所有程序都使用这个表，那它就是一个全局的表，所以就叫全局描述符表（GDT，Global Descriptor Table）。这个表又是存储在内存中的，如何找到这个表呢？答案就是有一个寄存器专门存放全局描述符表在内存中的地址，叫做全局描述符表寄存器（GDTR，Global Descriptor Table Register）。GDTR寄存器中的低16位用于表示表的长度，那么这个表中的元素可以有216个。LGDT指令用于将GDT表的从内存加载到GDTR寄存器，SGDT指令用于将GDT的基地址和界限从GDTR寄存器存储到内存中。</p> <h3 id="_4-10-3-段选择子-段选择器"><a href="#_4-10-3-段选择子-段选择器" class="header-anchor">#</a> 4.10.3 段选择子(段选择器)</h3> <p>程序执行时，通过CS代码段寄存器中的下标来查询GDT全局描述符表，这个下标叫做段选择子(也叫段选择器)，段选择子用于指明GDT表中的索引号，从而获取到表中的元素，表中的元素叫做段描述符，为什么叫做段描述符？因为它保存了段的元数据信息，包括段的界限，可执行、只读等标识符、权限位等信息。</p> <p><img src="/sun-blog/assets/img/image20.b1319733.png" alt="段选择器"></p> <p>一个段选择子有16bit组成，它不直接指向段，但是它指向段描述符。Index：这个就是前面说的GDT表的索引下标，用于指向GDT或LDT，16bit中的第3-15位能够在GDT或LDT中查找8192个元素；TI标识占用1bit，0表示指向GDT，1表示指向LDT；段选择子的后2bit，用来表示特权级。LDT与特权级的概念还未涉及，暂时忽略。</p> <h3 id="_4-10-4-段寄存器"><a href="#_4-10-4-段寄存器" class="header-anchor">#</a> 4.10.4 段寄存器</h3> <p>段寄存器之前有提到，它是一个广泛的名称，各种各样的段都可以称为段寄存器，如代码段寄存器、数据段寄存器、栈段寄存器等，除了这3个段寄存器，处理器也提供了其他3个段寄存器，ES，FS和GS，它们可以为当前正在执行的程序提供额外的数据段，属于通用寄存器。</p> <p>一个程序想要访问一个段，段的段选择子必须被加载到段寄存器中，尽管一个系统可以定义成千上万个段，但是只有6个能同时使用，也就是你可以在GDTR中存储很多段描述符，但同时能访问的只有6个，也就是处理器提供的那6个段寄存器，其他段可以通过在程序执行期间将它们的段选择子加载到这些寄存器中。</p> <p>段寄存器包含可见部分和不可见部分，可见部分就是段选择子，隐藏部分包含基地址、段界限、访问信息，隐藏部分相当于是缓存(也叫shadow register)，也就是第一次根据段选择子在GDT表中查到的段描述符信息缓存到隐藏部分，下次再使用到这个段选择子，直接可以拿到段描述符信息，而无需再查询GDT表。</p> <p><img src="/sun-blog/assets/img/image21.26076fce.png" alt="段选择器"></p> <h3 id="_4-10-5-段描述符"><a href="#_4-10-5-段描述符" class="header-anchor">#</a> 4.10.5 段描述符</h3> <p>程序执行时，通过CS代码段寄存器中的段选择子来查询GDT全局描述符表，段选择子用于指明GDT表中的索引号，从而获取到表中的元素，表中的元素叫做段描述符。为什么叫做段描述符？因为它保存了段的元数据信息，包括段的界限，可执行、只读等标识符、权限位等信息。</p> <p>段描述符是一个数据结构，保存在GDT或LDT表中，LDT暂时忽略，用于表示段的大小和位置，也就是基地址：base address和段限长：limit，还有一些控制符和状态信息，段描述符通畅由编译器、链接器、加载器、操作系统或执行时创建，而不是由应用程序来创建。</p> <h3 id="_4-10-6-特权级"><a href="#_4-10-6-特权级" class="header-anchor">#</a> 4.10.6 特权级</h3> <p>Intel将特权级划分了4个，分别是0、1、2、3，用二进制表示分别是：00、01、10、11，0是最高特权级，3是最低特权级，在Linux系统中只使用了0和3这两个特权级，所以1和2暂时不用了解。每个程序都会有自己的特权级，操作系统也有自己的特权级，操作系统的特权级一定是最高的，其他的程序的特权级一定比操作系统的低，如果程序要做某些操作，首先就需要特权级校验，检查在你的特权级范围内是否允许该操作。比如其他程序想要操作全局描述符表，那一定是不允许的。0的特权级最高，3的特权级最低，从0~3形成一个保护环境，所以也可以称为ring 0特权级和ring 3特权级。</p> <p><img src="/sun-blog/assets/img/image22.6072d142.png" alt="特权级"></p> <h3 id="_4-10-7-cpl、rpl、dpl"><a href="#_4-10-7-cpl、rpl、dpl" class="header-anchor">#</a> 4.10.7 CPL、RPL、DPL</h3> <p><strong>CPL(Current Privilege Level)</strong>，指当前特权级。它存储在CS和SS段段寄存器的后2位。一个程序执行中若执行自己的代码那么CPL特权级就应该是ring 3的，如果中间通过调用来执行操作系统内核代码那么CPL特权级就应该是ring 0的，由此可以理解为CPL就是指当前正在执行的程序或任务的特权级，当前也就是Current，所以叫CPL。</p> <p>RPL(Requested Privilege Level)，指请求特权级。RPL是分配给段选择子的，存储在段选择子的后2位。一个程序执行指令时会涉及到获取数据，访问数据同样需要查GDT表，只不过使用的是DS数据段寄存器中的段选择子去查询，在查表时，就需要有一个特权级来表示，当前请求数据的权限是什么，请求也就是Request，所以叫RPL。</p> <p>DPL(Descriptor privilege level)，因为这个特权级存放在段描述符中，所以叫DPL，表示了这个段的特权级。DPL是存放在段描述符中的，程序通过查询GDT表来获取段描述符，拿到段描述符中的段的基地址，是否允许访问这个段，是需要拿DPL做比较的。</p> <p>DPL、RPL、CPL之间如何进行比较？不管是CPL还是RPL，最终需要与DPL做对比：CPL=0，RPL=3，用3与DPL做对比。CPL=3，RPL=0，用3与DPL做对比。也就是说，cpl和rpl比较，得出权限最低的(也就是数值最大的)，再去和dpl比较，如果权限高于或等于dpl(也就是数值&lt;=dpl)，就是可以访问的。</p> <h3 id="_4-10-8-一致性代码段和非一致性代码段"><a href="#_4-10-8-一致性代码段和非一致性代码段" class="header-anchor">#</a> 4.10.8 一致性代码段和非一致性代码段</h3> <p><strong>一致性代码段</strong>：内核指令中有一段数据，它是可以让程序直接调用，这些就是一致性代码。也就是操作系统内核提供了一些功能或函数，允许应用程序直接调用，与特权级没关系，直接就可以调用，哪怕是特权级不够也可以调用，这种叫一致性代码。类似于API接口白名单，不需要token校验就可以访问一样。一致性代码不需要特权级检查。</p> <p><strong>非一致性代码段</strong>：操作系统内核大部分都是非一致性代码，也就是不允许直接调用，因为它可能关乎到操作系统内核的安全，此时应用程序要来访问，就要进行特权级校验，要求特权级必须相等，哪怕你权限够高都不行，必须相等才能访问。</p> <h3 id="_4-10-9-实模式与保护模式的区别"><a href="#_4-10-9-实模式与保护模式的区别" class="header-anchor">#</a> 4.10.9 实模式与保护模式的区别</h3> <p><strong>实模式</strong>：以前16位CPU，使用指令地址寄存器(16bit)+段寄存器(16bit中的4bit) = 物理地址，这种方式叫做实模式，实的意思就是生成的代码就可以直接操作物理地址。实模式是需要预先规划好地址的。</p> <p><strong>保护模式</strong>：通过段寄存器查GDT表+指令地址寄存器，这种方式叫做保护模式。</p> <h2 id="_4-11-指令流水线"><a href="#_4-11-指令流水线" class="header-anchor">#</a> 4.11 指令流水线</h2> <p>取指令、译码、执行、访问内存、写回内存。没有流水线，1-5一起执行，后面的等着。</p> <p>有了流水线，1-5分开，串开执行。</p> <p>TODO 此处未编写完成......</p> <h2 id="_4-12-intel-cpu寄存器命名规则"><a href="#_4-12-intel-cpu寄存器命名规则" class="header-anchor">#</a> 4.12 Intel CPU寄存器命名规则</h2> <p>Intel的16bit的CPU，可分高8位、低8位，AX、BX、CX、DX这四个都属于通用寄存器，它们都可以拆分成高8位和低8位来使用，比如AX拆分成AH和AL。AX寄存器可以用于做累加寄存器。BX寄存器可以用于做基地址寄存器。CX寄存器可以用于做计数寄存器。DX寄存器可以用于做数据寄存器。这类寄存器都是16位的寄存器。</p> <p>E开头的寄存器，如EAX、EBX、ECX、EDX等，都属于32位的寄存器。</p> <p>R开头的寄存器，如RAX、RBX、RCX、RDX等，都属于64位寄存器。</p> <p>在汇编语言中，b表示1byte，w表示2byte(16bit)，l表示4byte(32bit)、q表示8byte(64位)。</p> <h2 id="_4-13-si和di变址寄存器"><a href="#_4-13-si和di变址寄存器" class="header-anchor">#</a> 4.13 SI和DI变址寄存器</h2> <p>SI：s表示source，源的意思。</p> <p>DI：d表示destination，目的地的意思。</p> <p>I表示index。</p> <p>变址寄存器：它们主要用于存放存储单元在段内的偏移量。</p> <p>当使用ASCII编码时，一个字符在内存单元占用1byte，而内存单元的基础存储大小位1byte，所以字符串在内存中的标识为一个连续的byte数组。</p> <p>拷贝字符串，需要两个段，一个段指向原字符串所在的段，SI指向了所在段内的偏移量。另一个段指向目标段(也就是要拷贝到哪里)，DI指向了目标段内的偏移量。拷贝字符串由于SI和DI寄存器一次只能存储16bit的数据，所以需要拷贝多次，至于拷贝几次有通用寄存器CX(counter register)表示，CX也就是计数用的。</p> <p>字符串拷贝的指令就依赖SI和DI寄存器。SI和DI寄存器是在16位机中使用的，在32位机中叫ESI和EDI寄存器，会将ESI和EDI分别拆分成高16位和低16位的寄存器，低16位是用于兼容之前16位机数据的存储。变址寄存器不可再被拆分，比如已经拆分成高16位和低16位不可再拆分成高8位和低8位。</p> <p>Linux内核0.11源码，<code>bootsect.s</code>。注：实模式寻址</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">//Intel的汇编语法是从右往左的</span>
BOOTSEG  <span class="token operator">=</span> <span class="token number">0x07c0</span>			<span class="token operator">!</span> original address of boot<span class="token operator">-</span>sector		<span class="token comment">//低地址</span>
INITSEG  <span class="token operator">=</span> <span class="token number">0x9000</span>			<span class="token operator">!</span> we move boot here <span class="token operator">-</span> out of the way	<span class="token comment">//高地址</span>
entry _start
_start<span class="token operator">:</span>
	<span class="token comment">//将#BOOTSEG移动到ax寄存器</span>
	mov	ax<span class="token punctuation">,</span>#BOOTSEG
	<span class="token comment">//将ax寄存器中的值移动到ds寄存器，Intel汇编要求段寄存器不能直接用立即数传入，必须通过某个寄存器中转</span>
    <span class="token comment">//此时ds为源变址寄存器，指向了数据所在的段，也就是源段，ds=#BOOTSEG</span>
	mov	ds<span class="token punctuation">,</span>ax
	<span class="token comment">//将#INITSEG移动到ax寄存器</span>
	mov	ax<span class="token punctuation">,</span>#INITSEG
	<span class="token comment">//将ax寄存器中的值移动到es寄存器</span>
	<span class="token comment">//此时es变为目的变址寄存器，指向了数据即将移动到的段，也就是目的段，es=#INITSEG</span>
	mov	es<span class="token punctuation">,</span>ax
	<span class="token comment">//将#256移动到cx寄存器，表示要移动256次</span>
	mov	cx<span class="token punctuation">,</span>#<span class="token number">256</span>
	<span class="token comment">//si是数据所在段内的偏移量，sub减法运算，将si清0</span>
	sub	si<span class="token punctuation">,</span>si
	<span class="token comment">//di是目的段内的偏移量，sub减法运算，将di清0</span>
	sub	di<span class="token punctuation">,</span>di
	<span class="token comment">//repeat重复执行movw指令，w表示2byte，每次移动2byte，移动256次，</span>
	<span class="token comment">//总共移动了512byte的数据，从#BOOTSEG的位置移动到了#INITSEG位置</span>
	<span class="token comment">//每移动一次cx减1，si和di分别加上2byte</span>
	rep
	<span class="token comment">//移动2byte</span>
	movw
	jmpi go<span class="token punctuation">,</span>INITSEG

ds数据段寄存器<span class="token operator">:</span>si源变址寄存器 <span class="token operator">-&gt;</span> es扩展段寄存器<span class="token operator">:</span>di目的变址寄存器
为什么要移动，因为BOOTSEG那块的空间，之后要使用
</code></pre></div></div></section> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/sun-blog/computer-dao/3/第3章-编译原理.html" class="prev">
          第3章-编译原理
        </a></span> <span class="next"><a href="/sun-blog/computer-dao/5/第5章-C语言.html">
          第5章-C语言
        </a></span></p></div> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:12rem;" data-v-b57cc07c data-v-7dd95ae2><li class="level-2" data-v-b57cc07c><a href="/sun-blog/computer-dao/4/%E7%AC%AC4%E7%AB%A0-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80.html#_4-1-汇编语法" class="sidebar-link reco-side-_4-1-汇编语法" data-v-b57cc07c>4.1 汇编语法</a></li><li class="level-2" data-v-b57cc07c><a href="/sun-blog/computer-dao/4/%E7%AC%AC4%E7%AB%A0-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80.html#_4-2-mov、add、sub指令" class="sidebar-link reco-side-_4-2-mov、add、sub指令" data-v-b57cc07c>4.2 MOV、ADD、SUB指令</a></li><li class="level-3" data-v-b57cc07c><a href="/sun-blog/computer-dao/4/%E7%AC%AC4%E7%AB%A0-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80.html#_4-2-1-mov" class="sidebar-link reco-side-_4-2-1-mov" data-v-b57cc07c>4.2.1 MOV</a></li><li class="level-3" data-v-b57cc07c><a href="/sun-blog/computer-dao/4/%E7%AC%AC4%E7%AB%A0-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80.html#_4-2-2-add" class="sidebar-link reco-side-_4-2-2-add" data-v-b57cc07c>4.2.2 ADD</a></li><li class="level-3" data-v-b57cc07c><a href="/sun-blog/computer-dao/4/%E7%AC%AC4%E7%AB%A0-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80.html#_4-2-3-sub" class="sidebar-link reco-side-_4-2-3-sub" data-v-b57cc07c>4.2.3 SUB</a></li><li class="level-2" data-v-b57cc07c><a href="/sun-blog/computer-dao/4/%E7%AC%AC4%E7%AB%A0-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80.html#_4-3-指令地址寄存器" class="sidebar-link reco-side-_4-3-指令地址寄存器" data-v-b57cc07c>4.3 指令地址寄存器</a></li><li class="level-2" data-v-b57cc07c><a href="/sun-blog/computer-dao/4/%E7%AC%AC4%E7%AB%A0-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80.html#_4-4-寄存器组" class="sidebar-link reco-side-_4-4-寄存器组" data-v-b57cc07c>4.4 寄存器组</a></li><li class="level-2" data-v-b57cc07c><a href="/sun-blog/computer-dao/4/%E7%AC%AC4%E7%AB%A0-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80.html#_4-5-立即数和内存地址" class="sidebar-link reco-side-_4-5-立即数和内存地址" data-v-b57cc07c>4.5 立即数和内存地址</a></li><li class="level-3" data-v-b57cc07c><a href="/sun-blog/computer-dao/4/%E7%AC%AC4%E7%AB%A0-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80.html#_4-5-1-立即数" class="sidebar-link reco-side-_4-5-1-立即数" data-v-b57cc07c>4.5.1 立即数</a></li><li class="level-3" data-v-b57cc07c><a href="/sun-blog/computer-dao/4/%E7%AC%AC4%E7%AB%A0-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80.html#_4-5-2-内存地址" class="sidebar-link reco-side-_4-5-2-内存地址" data-v-b57cc07c>4.5.2 内存地址</a></li><li class="level-3" data-v-b57cc07c><a href="/sun-blog/computer-dao/4/%E7%AC%AC4%E7%AB%A0-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80.html#_4-5-3-十六进制" class="sidebar-link reco-side-_4-5-3-十六进制" data-v-b57cc07c>4.5.3 十六进制</a></li><li class="level-3" data-v-b57cc07c><a href="/sun-blog/computer-dao/4/%E7%AC%AC4%E7%AB%A0-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80.html#_4-5-4-高地址与低地址" class="sidebar-link reco-side-_4-5-4-高地址与低地址" data-v-b57cc07c>4.5.4 高地址与低地址</a></li><li class="level-2" data-v-b57cc07c><a href="/sun-blog/computer-dao/4/%E7%AC%AC4%E7%AB%A0-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80.html#_4-6-总线" class="sidebar-link reco-side-_4-6-总线" data-v-b57cc07c>4.6 总线</a></li><li class="level-2" data-v-b57cc07c><a href="/sun-blog/computer-dao/4/%E7%AC%AC4%E7%AB%A0-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80.html#_4-7-内存分段" class="sidebar-link reco-side-_4-7-内存分段" data-v-b57cc07c>4.7 内存分段</a></li><li class="level-3" data-v-b57cc07c><a href="/sun-blog/computer-dao/4/%E7%AC%AC4%E7%AB%A0-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80.html#_4-7-1-为什么要分段" class="sidebar-link reco-side-_4-7-1-为什么要分段" data-v-b57cc07c>4.7.1 为什么要分段？</a></li><li class="level-3" data-v-b57cc07c><a href="/sun-blog/computer-dao/4/%E7%AC%AC4%E7%AB%A0-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80.html#_4-7-2-代码段" class="sidebar-link reco-side-_4-7-2-代码段" data-v-b57cc07c>4.7.2 代码段</a></li><li class="level-3" data-v-b57cc07c><a href="/sun-blog/computer-dao/4/%E7%AC%AC4%E7%AB%A0-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80.html#_4-7-3-堆栈段" class="sidebar-link reco-side-_4-7-3-堆栈段" data-v-b57cc07c>4.7.3 堆栈段</a></li><li class="level-3" data-v-b57cc07c><a href="/sun-blog/computer-dao/4/%E7%AC%AC4%E7%AB%A0-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80.html#_4-7-4-栈顶和栈底寄存器" class="sidebar-link reco-side-_4-7-4-栈顶和栈底寄存器" data-v-b57cc07c>4.7.4 栈顶和栈底寄存器</a></li><li class="level-3" data-v-b57cc07c><a href="/sun-blog/computer-dao/4/%E7%AC%AC4%E7%AB%A0-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80.html#_4-7-5-数据段" class="sidebar-link reco-side-_4-7-5-数据段" data-v-b57cc07c>4.7.5 数据段</a></li><li class="level-3" data-v-b57cc07c><a href="/sun-blog/computer-dao/4/%E7%AC%AC4%E7%AB%A0-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80.html#_4-7-6-操作系统内存及内存排列" class="sidebar-link reco-side-_4-7-6-操作系统内存及内存排列" data-v-b57cc07c>4.7.6 操作系统内存及内存排列</a></li><li class="level-2" data-v-b57cc07c><a href="/sun-blog/computer-dao/4/%E7%AC%AC4%E7%AB%A0-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80.html#_4-8-call指令和ret指令" class="sidebar-link reco-side-_4-8-call指令和ret指令" data-v-b57cc07c>4.8 CALL指令和RET指令</a></li><li class="level-3" data-v-b57cc07c><a href="/sun-blog/computer-dao/4/%E7%AC%AC4%E7%AB%A0-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80.html#_4-8-1-call指令" class="sidebar-link reco-side-_4-8-1-call指令" data-v-b57cc07c>4.8.1 CALL指令</a></li><li class="level-3" data-v-b57cc07c><a href="/sun-blog/computer-dao/4/%E7%AC%AC4%E7%AB%A0-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80.html#_4-8-2-状态寄存器" class="sidebar-link reco-side-_4-8-2-状态寄存器" data-v-b57cc07c>4.8.2 状态寄存器</a></li><li class="level-3" data-v-b57cc07c><a href="/sun-blog/computer-dao/4/%E7%AC%AC4%E7%AB%A0-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80.html#_4-8-2-ret指令" class="sidebar-link reco-side-_4-8-2-ret指令" data-v-b57cc07c>4.8.2 RET指令</a></li><li class="level-2" data-v-b57cc07c><a href="/sun-blog/computer-dao/4/%E7%AC%AC4%E7%AB%A0-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80.html#_4-9-intel-cpu发展史" class="sidebar-link reco-side-_4-9-intel-cpu发展史" data-v-b57cc07c>4.9 Intel CPU发展史</a></li><li class="level-2" data-v-b57cc07c><a href="/sun-blog/computer-dao/4/%E7%AC%AC4%E7%AB%A0-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80.html#_4-10-x86-32位cpu-保护模式" class="sidebar-link reco-side-_4-10-x86-32位cpu-保护模式" data-v-b57cc07c>4.10 x86(32位CPU)保护模式</a></li><li class="level-3" data-v-b57cc07c><a href="/sun-blog/computer-dao/4/%E7%AC%AC4%E7%AB%A0-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80.html#_4-10-1-虚拟内存" class="sidebar-link reco-side-_4-10-1-虚拟内存" data-v-b57cc07c>4.10.1 虚拟内存</a></li><li class="level-3" data-v-b57cc07c><a href="/sun-blog/computer-dao/4/%E7%AC%AC4%E7%AB%A0-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80.html#_4-10-2-全局描述符表-gdt-和全局描述符表寄存器-gdtr" class="sidebar-link reco-side-_4-10-2-全局描述符表-gdt-和全局描述符表寄存器-gdtr" data-v-b57cc07c>4.10.2 全局描述符表(GDT)和全局描述符表寄存器(GDTR)</a></li><li class="level-3" data-v-b57cc07c><a href="/sun-blog/computer-dao/4/%E7%AC%AC4%E7%AB%A0-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80.html#_4-10-3-段选择子-段选择器" class="sidebar-link reco-side-_4-10-3-段选择子-段选择器" data-v-b57cc07c>4.10.3 段选择子(段选择器)</a></li><li class="level-3" data-v-b57cc07c><a href="/sun-blog/computer-dao/4/%E7%AC%AC4%E7%AB%A0-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80.html#_4-10-4-段寄存器" class="sidebar-link reco-side-_4-10-4-段寄存器" data-v-b57cc07c>4.10.4 段寄存器</a></li><li class="level-3" data-v-b57cc07c><a href="/sun-blog/computer-dao/4/%E7%AC%AC4%E7%AB%A0-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80.html#_4-10-5-段描述符" class="sidebar-link reco-side-_4-10-5-段描述符" data-v-b57cc07c>4.10.5 段描述符</a></li><li class="level-3" data-v-b57cc07c><a href="/sun-blog/computer-dao/4/%E7%AC%AC4%E7%AB%A0-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80.html#_4-10-6-特权级" class="sidebar-link reco-side-_4-10-6-特权级" data-v-b57cc07c>4.10.6 特权级</a></li><li class="level-3" data-v-b57cc07c><a href="/sun-blog/computer-dao/4/%E7%AC%AC4%E7%AB%A0-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80.html#_4-10-7-cpl、rpl、dpl" class="sidebar-link reco-side-_4-10-7-cpl、rpl、dpl" data-v-b57cc07c>4.10.7 CPL、RPL、DPL</a></li><li class="level-3" data-v-b57cc07c><a href="/sun-blog/computer-dao/4/%E7%AC%AC4%E7%AB%A0-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80.html#_4-10-8-一致性代码段和非一致性代码段" class="sidebar-link reco-side-_4-10-8-一致性代码段和非一致性代码段" data-v-b57cc07c>4.10.8 一致性代码段和非一致性代码段</a></li><li class="level-3" data-v-b57cc07c><a href="/sun-blog/computer-dao/4/%E7%AC%AC4%E7%AB%A0-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80.html#_4-10-9-实模式与保护模式的区别" class="sidebar-link reco-side-_4-10-9-实模式与保护模式的区别" data-v-b57cc07c>4.10.9 实模式与保护模式的区别</a></li><li class="level-2" data-v-b57cc07c><a href="/sun-blog/computer-dao/4/%E7%AC%AC4%E7%AB%A0-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80.html#_4-11-指令流水线" class="sidebar-link reco-side-_4-11-指令流水线" data-v-b57cc07c>4.11 指令流水线</a></li><li class="level-2" data-v-b57cc07c><a href="/sun-blog/computer-dao/4/%E7%AC%AC4%E7%AB%A0-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80.html#_4-12-intel-cpu寄存器命名规则" class="sidebar-link reco-side-_4-12-intel-cpu寄存器命名规则" data-v-b57cc07c>4.12 Intel CPU寄存器命名规则</a></li><li class="level-2" data-v-b57cc07c><a href="/sun-blog/computer-dao/4/%E7%AC%AC4%E7%AB%A0-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80.html#_4-13-si和di变址寄存器" class="sidebar-link reco-side-_4-13-si和di变址寄存器" data-v-b57cc07c>4.13 SI和DI变址寄存器</a></li></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/sun-blog/assets/js/app.8cc2e543.js" defer></script><script src="/sun-blog/assets/js/4.eab32c03.js" defer></script><script src="/sun-blog/assets/js/1.3b1cd4a9.js" defer></script><script src="/sun-blog/assets/js/5.dc06e3fc.js" defer></script>
  </body>
</html>
